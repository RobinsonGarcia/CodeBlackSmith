### __init__.py ###
# codepromptforge/__init__.py
"""
codepromptforge package initialization module.

This package provides functionality to combine code files into a single prompt,
making it easy to use with large language models (LLMs) for tasks such as
bug fixing, code improvements, and modifications.
"""
### __init__.py ###
from .assistant_registry import AssistantRegistry
from . import react_assistant  # Ensure assistants are loaded

__all__ = ["AssistantRegistry"]
### assistant_registry.py ###
from typing import Dict, Callable

class AssistantRegistry:
    """
    A registry for managing and retrieving assistant implementations dynamically.
    Each assistant must be registered with a unique name and a function that 
    builds the assistant using an LLM model.
    """

    _registry: Dict[str, Callable] = {}

    @classmethod
    def register_assistant(cls, name: str, builder: Callable):
        """
        Register an assistant with a unique name.

        Args:
            name (str): Unique identifier for the assistant.
            builder (Callable): A function that takes an LLM instance and returns the assistant.

        Raises:
            ValueError: If an assistant with the same name is already registered.
        """
        if name in cls._registry:
            raise ValueError(f"Assistant '{name}' is already registered.")
        cls._registry[name] = builder

    @classmethod
    def get_assistant(cls, name: str, llm, base_dir='..'):
        """
        Retrieve and build an assistant by name.

        Args:
            name (str): The name of the registered assistant.
            llm: The LLM model instance to be used by the assistant.

        Returns:
            The built assistant instance.

        Raises:
            KeyError: If the requested assistant is not found.
        """
        if name not in cls._registry:
            raise KeyError(f"Assistant '{name}' is not registered.")
        return cls._registry[name](llm, base_dir)

    @classmethod
    def list_assistants(cls):
        """
        List all registered assistants.

        Returns:
            List of registered assistant names.
        """
        return list(cls._registry.keys())
### react_assistant.py ###

from codepromptforge.main import CodePromptForge
from codepromptforge.prompt import react_template
from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver

from .assistant_registry import AssistantRegistry

# Define the assistant's prompt
prompt = react_template + "You are forbidden to call tools beyond the list provided."
memory = MemorySaver()


# Define the assistant builder function
def build_react_assistant(llm, base_dir):
    # Define the tools
    forge = CodePromptForge(base_dir=base_dir)
    tools = forge.get_tools()
    return create_react_agent(llm, tools=tools, prompt=prompt, checkpointer=memory)

# Register the assistant
AssistantRegistry.register_assistant("react_assistant", build_react_assistant)
### cli.py ###
import argparse
import json
import sys
import subprocess
from codepromptforge.main import (
    CodePromptForge, 
    InvalidBaseDirectoryError, 
    NoFilesFoundError, 
    OutputFileAlreadyExistsError
)

from codepromptforge.assistant import AssistantRegistry
from langchain_ollama import ChatOllama
import ollama
import uuid


class ModelNotFoundError(Exception):
    """Custom exception to handle missing Ollama models."""
    pass


def check_if_model_exists(model_name):
    """
    Checks if the given model is available in Ollama.
    
    Args:
        model_name (str): The name of the model to check.

    Returns:
        bool: True if the model exists, otherwise raises an error.
    
    Raises:
        ModelNotFoundError: If the model is not available in Ollama.
    """
    available_models = [m["name"] for m in ollama.list()["models"]]

    if model_name in available_models:
        return True
    else:
        error_message = (
            f"âŒ Model '{model_name}' not found in Ollama.\n"
            f"ðŸ“¥ To download it, run:\n\n"
            f"   ollama pull {model_name}\n"
            f"\nðŸ”¹ Available models: {', '.join(available_models) if available_models else 'None'}"
        )
        raise ModelNotFoundError(error_message)


def start_assistant(model_name, base_dir, **kwargs):
    """
    Instantiates an Ollama LLM model and runs an interactive assistant session.
    
    Args:
        model_name (str): The name of the Ollama model (e.g., "qwen2.5:14b", "llama3.3").
        **kwargs: Optional parameters for configuring the LLM model.
    """
    # Initialize Ollama model with optional parameters
    try:
        check_if_model_exists(model_name)  # Replace with your desired model
        print("âœ… Model is available.")
    except ModelNotFoundError as e:
        print(e)
        sys.exit(1)
    llm = ChatOllama(model=model_name, **kwargs)

    # Retrieve the assistant (defaults to "react_assistant")
    assistant_name = "react_assistant"
    if assistant_name not in AssistantRegistry.list_assistants():
        print(f"Error: Assistant '{assistant_name}' is not available.", file=sys.stderr)
        sys.exit(1)

    agent = AssistantRegistry.get_assistant(assistant_name, llm, base_dir)

    # Interactive CLI session
    print(f"ðŸ”¹ Running '{assistant_name}' assistant with Ollama model: {model_name}")
    print("ðŸ’¬ Type your messages below. Type 'exit' to quit.\n")

    thread_id = str(uuid.uuid4())

    while True:
        user_input = input("User: ")
        if user_input.lower() in ["exit", "quit"]:
            print("ðŸ”» Exiting assistant.")
            break

        try:

            inputs = {"messages": [("user", user_input)]}
            config = {"configurable": {"thread_id": thread_id}}
            response = agent.invoke(inputs, config=config)


            # Print the response
            if isinstance(response, dict) and "messages" in response:
                print(f"Assistant: {response['messages'][-1].content}")
            else:
                print(f"Assistant: {response.content}")
                
        except Exception as e:
            print(e)


def start_server(model_name, base_dir):
    """
    Launches the web server with specified model and base directory.
    
    Args:
        model_name (str): The Ollama model name.
        base_dir (str): The base directory for assistant operations.
    """
    print(f"ðŸš€ Starting web server with model '{model_name}' and base directory '{base_dir}'...")
    subprocess.run(["python", "codepromptforge/web_assistant/app.py", "--model", model_name, "--base-dir", base_dir])


def main():
    parser = argparse.ArgumentParser(description="Code management CLI.")
    parser.add_argument(
        "command",
        choices=["tree", "file", "files", "files_recursive", "write", "combine", "clean_result", "cli_assistant", "web_assistant"],
        help="Command to execute"
    )
    parser.add_argument("--folder", help="Folder path")
    parser.add_argument("--file", help="File path")
    parser.add_argument("--content", help="Content for writing")
    parser.add_argument("--base-dir", help="Base directory")
    parser.add_argument("--extensions", nargs="*", default=[], help="File extensions for combining")
    parser.add_argument("--output-file", help="Output file for combination")
    parser.add_argument("--force", action="store_true", help="Force overwrite existing output file")
    parser.add_argument("--exclude", nargs="*", default=[], help="List of files to exclude from concatenation")
    parser.add_argument("--exclude-clean", nargs="*", default=[], help="Files to remove from .result folder")
    
    # Arguments for Assistant
    parser.add_argument("--model", help="Ollama model to use (e.g., llama3.3, qwen2.5:14b)")
    parser.add_argument("--temperature", type=float, default=0.0, help="Temperature setting for the model")
    parser.add_argument("--num_ctx", type=int, default=80000, help="Context length for the model")

    args = parser.parse_args()

    # Handle assistant command
    if args.command == "cli_assistant":
        if not args.model:
            print("Error: --model argument is required for 'assistant' command.", file=sys.stderr)
            sys.exit(1)
        if not args.base_dir:
            print("Error: --base_dir argument is required for 'assistant' command.", file=sys.stderr)
            sys.exit(1)
        # Collect optional LLM parameters
        llm_params = {
            "temperature": args.temperature,
            "num_ctx": args.num_ctx,
        }

        start_assistant(args.model, args.base_dir, **llm_params)
        return  # Exit after running assistant mode
    
    if args.command == "web_assistant":
        if not args.model or not args.base_dir:
            print("Error: --model and --base-dir are required for 'server' command.", file=sys.stderr)
            sys.exit(1)

        start_server(args.model, args.base_dir)
        return

    # Regular CLI Commands
    forge = CodePromptForge(
        base_dir=args.base_dir,
        output_file=args.output_file,
        force=args.force,
        excluded=args.exclude
    )

    try:
        if args.command == "tree":
            if not args.folder:
                print("Error: The --folder argument is required for 'tree' command.", file=sys.stderr)
                sys.exit(1)
            print(forge.get_directory_tree(args.folder))

        elif args.command == "file":
            if not args.file:
                print("Error: The --file argument is required for 'file' command.", file=sys.stderr)
                sys.exit(1)
            print(forge.get_file_content(args.file))

        elif args.command == "files":
            if not args.folder:
                raise ValueError("The --folder argument is required for 'files' command.")
            print(json.dumps(forge.get_files_in_folder(args.folder), indent=2))

        elif args.command == "files_recursive":
            if not args.folder:
                raise ValueError("The --folder argument is required for 'files_recursive' command.")
            print(json.dumps(forge.get_files_recursively(args.folder), indent=2))

        elif args.command == "write":
            if not args.file or not args.content:
                raise ValueError("Both --file and --content arguments are required for 'write' command.")
            print(forge.write_file(args.file, args.content))

        elif args.command == "combine":
            if not args.extensions or not args.output_file:
                raise ValueError("--extensions and --output-file are required for 'combine'.")
            forge.forge_prompt(args.extensions)

        elif args.command == "clean_result":
            if not args.exclude_clean:
                raise ValueError("--exclude-clean argument is required for 'clean_result'.")
            forge.clean_result_folder(args.exclude_clean)

    except (InvalidBaseDirectoryError, NoFilesFoundError, OutputFileAlreadyExistsError, ValueError) as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
### main.py ###
import os
from pathlib import Path
from typing import List, Dict, Optional, Type
from pydantic import BaseModel, Field
from langchain_core.tools import BaseTool
import pathspec  # âœ… Added for .gitignore handling
from langchain_community.tools import DuckDuckGoSearchRun, DuckDuckGoSearchResults
class InvalidBaseDirectoryError(Exception):
    pass

class NoFilesFoundError(Exception):
    pass

class OutputFileAlreadyExistsError(Exception):
    pass

class CodePromptForge:
    def __init__(
        self,
        base_dir: str = ".",
        output_file: str = None,
        dry_run: bool = False,
        force: bool = False,
        include_tree: bool = False,
        excluded: Optional[List[str]] = None
    ):
        self.base_dir = Path(base_dir).resolve()
        if not self.base_dir.exists() or not self.base_dir.is_dir():
            raise InvalidBaseDirectoryError(f"Base directory '{self.base_dir}' does not exist or is not a directory.")

        self.output_file = Path(output_file) if output_file else None
        self.dry_run = dry_run
        self.force = force
        self.include_tree = include_tree
        self.result_dir = self.base_dir / ".result"
        self.result_dir.mkdir(parents=True, exist_ok=True)

        # Load .gitignore patterns
        self.gitignore_spec = self._load_gitignore()

        # Convert excluded files into a set for quick lookup
        self.excluded = set(excluded or [])

    def _load_gitignore(self) -> Optional[pathspec.PathSpec]:
        """Loads `.gitignore` and compiles it into a pathspec matcher."""
        gitignore_path = self.base_dir / ".gitignore"
        if not gitignore_path.exists():
            return None  # No .gitignore found

        with gitignore_path.open("r", encoding="utf-8") as f:
            gitignore_patterns = f.readlines()

        return pathspec.PathSpec.from_lines("gitwildmatch", gitignore_patterns)

    def _is_ignored(self, file_path: Path) -> bool:
        """Checks if a file is ignored by .gitignore, explicitly excluded, or in `.git`."""
        relative_path = str(file_path.relative_to(self.base_dir))
        return (
            (self.gitignore_spec and self.gitignore_spec.match_file(relative_path))  # âœ… Checks against .gitignore
            or (relative_path in self.excluded)  # âœ… Explicit exclusions
            or (".git/" in relative_path or relative_path.startswith(".git"))  # âœ… Always ignore `.git`
        )

    def get_directory_tree(self, folder_path: str) -> List[str]:
        """Returns a list of all files in the specified folder, excluding ignored ones."""
        target_path = self.base_dir / folder_path
        if not target_path.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_path}")

        return [
            str(file.relative_to(self.base_dir))
            for file in target_path.rglob("*")
            if file.is_file() and not self._is_ignored(file)
        ]

    def get_file_content(self, file_path: str) -> str:
        target_file = self.base_dir / file_path
        if not target_file.is_file() or self._is_ignored(target_file):
            raise FileNotFoundError(f"File not found or ignored: {target_file}")
        return target_file.read_text(encoding="utf-8")

    def get_files_in_folder(self, folder_path: str) -> Dict[str, str]:
        target_folder = self.base_dir / folder_path
        if not target_folder.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_folder}")

        return {
            file.name: file.read_text(encoding="utf-8")
            for file in target_folder.iterdir()
            if file.is_file() and not self._is_ignored(file)
        }

    def get_files_recursively(self, folder_path: str) -> Dict[str, str]:
        target_folder = self.base_dir / folder_path
        if not target_folder.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_folder}")

        return {
            str(file.relative_to(self.base_dir)): file.read_text(encoding="utf-8")
            for file in target_folder.rglob("*")
            if file.is_file() and not self._is_ignored(file)
        }

    def write_file(self, file_path: str, content: str) -> str:
        """Writes a file inside .result folder and ensures it exists."""
        self.result_dir.mkdir(parents=True, exist_ok=True)
        result_file = self.result_dir / file_path
        result_file.write_text(content, encoding="utf-8")
        return f"File written successfully: {result_file}"

    def find_files(self, extensions: List[str]) -> List[Path]:
        matched_files = [
            file_path
            for ext in extensions
            for file_path in self.base_dir.rglob(f"*.{ext}")
            if not self._is_ignored(file_path)
        ]
        if not matched_files:
            raise NoFilesFoundError(f"No files found for extensions {extensions} in '{self.base_dir}'.")
        return sorted(set(matched_files))

    def _validate_output_file(self) -> None:
        """Ensures output file does not already exist unless force=True."""
        if self.output_file and self.output_file.exists() and not self.force:
            raise OutputFileAlreadyExistsError(
                f"Output file '{self.output_file}' already exists. Use --force to overwrite."
            )

    def forge_prompt(self, extensions: List[str]) -> None:
        self._validate_output_file()
        files = self.find_files(extensions)
        if self.dry_run:
            print("\n".join(str(f) for f in files))
            return
        if not files:
            print("No files found for combination.")
            return
        self.output_file.parent.mkdir(parents=True, exist_ok=True)
        with self.output_file.open('w', encoding='utf-8') as outfile:
            if self.include_tree:
                outfile.write("Directory Tree:\n")
                outfile.write("\n".join(self.get_directory_tree(".")) + "\n")
            for file in files:
                outfile.write(f"### {file.name} ###\n")
                outfile.write(file.read_text(encoding="utf-8"))
                outfile.write("\n")

    def run(self, extensions: List[str]) -> None:
        self.forge_prompt(extensions)

    def clean_result_folder(self, excluded_files: List[str]) -> None:
        self.result_dir.mkdir(parents=True, exist_ok=True)
        deleted_files = []
        for file_name in excluded_files:
            file_path = self.result_dir / file_name
            if file_path.exists() and file_path.is_file():
                file_path.unlink()
                deleted_files.append(file_name)
        print(f"Cleaned .result folder. Removed files: {deleted_files}")

    def get_tools(self) -> List[BaseTool]:
        """Returns LangChain-compatible tools with access to CodePromptForge methods."""

        class GetDirectoryTreeInput(BaseModel):
            folder_path: str = Field(..., description="The directory path to generate a tree from.")

        class GetFileContentInput(BaseModel):
            file_path: str = Field(..., description="Path of the file to read.")

        class WriteFileInput(BaseModel):
            file_path: str = Field(..., description="Path to save the file.")
            content: str = Field(..., description="Content to be written in the file.")

        class CleanResultFolderInput(BaseModel):
            excluded_files: List[str] = Field(..., description="List of filenames to remove inside .result folder.")

        class GetFilesInFolderInput(BaseModel):
            folder_path: str = Field(..., description="Path of the folder to list files from.")

        class GetFilesRecursivelyInput(BaseModel):
            folder_path: str = Field(..., description="Path of the folder to recursively list files.")

        class FindFilesInput(BaseModel):
            extensions: List[str] = Field(..., description="List of file extensions to search for.")

        class ForgePromptInput(BaseModel):
            extensions: List[str] = Field(..., description="List of file extensions to include in the prompt.")

        forge = self

        class GetDirectoryTreeTool(BaseTool):
            name: str = "get_directory_tree"
            description: str = "Returns a list of all files in the specified folder, with paths relative to the base directory."
            args_schema: Type[BaseModel] = GetDirectoryTreeInput

            def _run(self, folder_path: str) -> List[str]:
                return forge.get_directory_tree(folder_path)

        class GetFileContentTool(BaseTool):
            name: str = "get_file_content"
            description: str = "Retrieves the content of a specified file."
            args_schema: Type[BaseModel] = GetFileContentInput

            def _run(self, file_path: str) -> str:
                return forge.get_file_content(file_path)

        class GetFilesInFolderTool(BaseTool):
            name: str = "get_files_in_folder"
            description: str = "Lists all files in the specified folder."
            args_schema: Type[BaseModel] = GetFilesInFolderInput

            def _run(self, folder_path: str) -> Dict[str, str]:
                return forge.get_files_in_folder(folder_path)

        class GetFilesRecursivelyTool(BaseTool):
            name: str = "get_files_recursively"
            description: str = "Lists all files in a folder and its subfolders."
            args_schema: Type[BaseModel] = GetFilesRecursivelyInput

            def _run(self, folder_path: str) -> Dict[str, str]:
                return forge.get_files_recursively(folder_path)

        class FindFilesTool(BaseTool):
            name: str = "find_files"
            description: str = "Finds files with the specified extensions in the base directory."
            args_schema: Type[BaseModel] = FindFilesInput

            def _run(self, extensions: List[str]) -> List[str]:
                return [str(file) for file in forge.find_files(extensions)]

        class WriteFileTool(BaseTool):
            name: str = "write_file"
            description: str = "Writes content to a file inside the .result folder."
            args_schema: Type[BaseModel] = WriteFileInput

            def _run(self, file_path: str, content: str) -> str:
                return forge.write_file(file_path, content)

        class CleanResultFolderTool(BaseTool):
            name: str = "clean_result_folder"
            description: str = "Deletes specific files inside the .result folder."
            args_schema: Type[BaseModel] = CleanResultFolderInput

            def _run(self, excluded_files: List[str]) -> None:
                return forge.clean_result_folder(excluded_files)

        class ForgePromptTool(BaseTool):
            name: str = "forge_prompt"
            description: str = "Combines and processes code files into a single prompt."
            args_schema: Type[BaseModel] = ForgePromptInput

            def _run(self, extensions: List[str]) -> None:
                return forge.forge_prompt(extensions)

        class RunTool(BaseTool):
            name: str = "run"
            description: str = "Runs the forge process on the specified file extensions."
            args_schema: Type[BaseModel] = ForgePromptInput

            def _run(self, extensions: List[str]) -> None:
                return forge.run(extensions)

        return [
            GetDirectoryTreeTool(),
            GetFileContentTool(),
            GetFilesInFolderTool(),
            GetFilesRecursivelyTool(),
            FindFilesTool(),
            WriteFileTool(),
            CleanResultFolderTool(),
            ForgePromptTool(),
            RunTool(),
            DuckDuckGoSearchRun(), 
            DuckDuckGoSearchResults(backend="news")
        ]
### prompt.py ###
react_template = """
You are an AI code reviewer and generator, responsible for analyzing and improving software projects. Your goal is to assist in reviewing, modifying, and generating high-quality code while leveraging the available tools.

You may also be requested to generate prompts with enougth context to fix or write a new feature.

Be friendly and chat with the user about any topic. You may search the web, using duckduckgo, to gather additional context to answer questions or to interact.
Don`t call other tools unless you engage in a code review process.

When asked to work on a codebase here are your Guidelines

	1.	Understand the Context
	â€¢	Start by retrieving the directory tree using get_directory_tree to get an overview of the project.
	â€¢	Identify relevant files for analysis using find_files (e.g., Python, JavaScript, or other specified extensions).
	2.	Analyze the Codebase
	â€¢	Read individual files with get_file_content to understand their structure and functionality.
	â€¢	If a specific folder needs inspection, use get_files_in_folder or get_files_recursively.
	3.	Apply Code Review Principles
	â€¢	Look for bugs, security risks, and inefficiencies in the code.
	â€¢	Identify inconsistent styles, redundant code, or performance issues.
	â€¢	Ensure compliance with best practices and design patterns.
	4.	Enhance and Optimize Code
	â€¢	If issues are found, suggest improvements, refactors, or optimizations.
	â€¢	If a function, class, or module is missing, generate the necessary code.
	â€¢	Ensure that any new code aligns with existing conventions and patterns.
	5.	Write and Save Modifications
	â€¢	If a change is required, write modified code to a file using write_file.
	â€¢	If multiple changes are needed, manage them efficiently without overwriting critical files.
	6.	Ensure Clean Project State
	â€¢	Before finalizing, check the .result folder for unnecessary files and remove them using clean_result_folder.
	â€¢	Ensure that ignored files (from .gitignore) are not included in the process.

Tools Available

You have access to the following tools:
	â€¢	get_directory_tree(folder_path): Retrieve a list of all files in a given folder.
	â€¢	get_file_content(file_path): Read the contents of a specific file.
	â€¢	get_files_in_folder(folder_path): List all files in a folder.
	â€¢	get_files_recursively(folder_path): Retrieve files from a folder and its subdirectories.
	â€¢	find_files(extensions): Find all files matching a given set of extensions.
	â€¢	write_file(file_path, content): Write or overwrite a file.
	â€¢	clean_result_folder(excluded_files): Remove unnecessary files from the .result folder.
	â€¢	forge_prompt(extensions): Generate a combined prompt from selected files.
	â€¢	duckduckgo_search(query: str): Searchs the web
    â€¢	duckduckgo_results_json(query: str): Searchs the web, and returns news and more detailed info


Expected Workflow for codereview
	1.	Retrieve the project structure using get_directory_tree.
	2.	Identify key files using find_files(["py"]) (or other specified extensions).
	3.	Analyze relevant files using get_file_content.
	4.	Identify areas for improvement (bugs, optimizations, security).
	5.	Suggest and generate improved code where necessary.
	6.	Write updated files using write_file without overriding critical files.
	7.	Ensure clean project state using clean_result_folder where appropriate.

Your task is to review, analyze, and generate code while following best practices. If modifications are needed, ensure they are well-structured and aligned with the existing codebase.
or, just assist the user with his/her needs. Use unicode emoji`s to make the conversation more interesting and engaging
"""

### app.py ###
from flask import Flask, render_template, request, jsonify, session
from codepromptforge.assistant import AssistantRegistry
from langchain_ollama import ChatOllama
import ollama
import re
import argparse
import uuid
import os

app = Flask(__name__)
app.secret_key = "supersecretkey"  # Required for session tracking

def get_available_models():
    """Returns a list of available models in Ollama."""
    try:
        return [m["name"] for m in ollama.list()["models"]]
    except Exception:
        return []

def format_response(response):
    """Formats assistant response to preserve code formatting."""
    response = re.sub(r"```python\n(.*?)\n```", r'<pre><code class="language-python">\1</code></pre>', response, flags=re.DOTALL)
    response = re.sub(r"```markdown\n(.*?)\n```", r'<pre><code class="language-markdown">\1</code></pre>', response, flags=re.DOTALL)
    return response.replace("\n", "<br>")

# Parse CLI arguments
parser = argparse.ArgumentParser(description="Start web assistant")
parser.add_argument("--model", required=True, help="Ollama model name")
parser.add_argument("--base-dir", required=True, help="Base directory for file operations")
args = parser.parse_args()

# Convert base_dir to an absolute path
BASE_DIR = os.path.abspath(args.base_dir)  # âœ… Ensure correct path

# Change working directory to base_dir
os.chdir(BASE_DIR)  # âœ… Ensure app has access to base_dir files

print(f"ðŸ”¹ Server running with base directory: {BASE_DIR}")

# Initialize LLM
llm = ChatOllama(model=args.model)

# Retrieve assistant with `base_dir`
assistant_name = "react_assistant"
agent = AssistantRegistry.get_assistant(assistant_name, llm, BASE_DIR)  # âœ… Pass absolute base_dir

@app.route("/")
def index():
    """Render the chat UI."""
    if "thread_id" not in session:
        session["thread_id"] = str(uuid.uuid4())  # âœ… Generate unique thread_id

    return render_template(
        "index.html",
        models=get_available_models(),
        selected_model=args.model,
        base_dir=BASE_DIR,  # âœ… Pass absolute base_dir
        thread_id=session["thread_id"]
    )

@app.route("/chat", methods=["POST"])
def chat():
    """Handle user input with thread_id for session tracking."""
    user_input = request.json.get("message")
    if not user_input:
        return jsonify({"error": "Empty input!"}), 400

    thread_id = session.get("thread_id", str(uuid.uuid4()))  # âœ… Ensure thread_id persists

    inputs = {"messages": [("user", user_input)]}
    config = {"configurable": {"thread_id": thread_id}}  # âœ… Include memory tracking

    response = agent.invoke(inputs, config=config)

    assistant_response = response["messages"][-1].content if "messages" in response else response.content
    return jsonify({"message": format_response(assistant_response)})

if __name__ == "__main__":
    app.run(debug=True, port=5000)
