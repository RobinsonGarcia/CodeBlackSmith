### __init__.py ###

### __init__.py ###
from .common.assistant_registry import AssistantRegistry
from . import cli

__all__ = [AssistantRegistry, cli]

### cli.py ###
import sys
import subprocess
import uuid
from .common import AssistantRegistry
from langchain_ollama import ChatOllama
import ollama

#############################
# Assistant Module Utilities#
#############################
class ModelNotFoundError(Exception):
    """Custom exception to handle missing Ollama models."""
    pass

def check_if_model_exists(model_name):
    available_models = [m["model"] for m in ollama.list()["models"]]
    if model_name in available_models:
        return True
    else:
        error_message = (
            f"❌ Model '{model_name}' not found in Ollama.\n"
            f"📥 To download it, run:\n\n"
            f"   ollama pull {model_name}\n"
            f"\n🔹 Available models: {', '.join(available_models) if available_models else 'None'}"
        )
        raise ModelNotFoundError(error_message)

#########################
# Assistant CLI Handlers#
#########################
def start_assistant(model_name, base_dir, temperature, num_ctx):
    try:
        check_if_model_exists(model_name)
        print("✅ Model is available.")
    except ModelNotFoundError as e:
        print(e, file=sys.stderr)
        sys.exit(1)
    llm = ChatOllama(model=model_name, temperature=temperature, num_ctx=num_ctx)
    assistant_name = "react_assistant"
    if assistant_name not in AssistantRegistry.list_assistants():
        print(f"Error: Assistant '{assistant_name}' is not available.", file=sys.stderr)
        sys.exit(1)
    agent = AssistantRegistry.get_assistant(assistant_name, llm, base_dir)
    print(f"🔹 Running '{assistant_name}' assistant with Ollama model: {model_name}")
    print("💬 Type your messages below. Type 'exit' to quit.\n")
    thread_id = str(uuid.uuid4())
    while True:
        user_input = input("User: ")
        if user_input.lower() in ["exit", "quit"]:
            print("🔻 Exiting assistant.")
            break
        try:
            inputs = {"messages": [("user", user_input)]}
            config = {"configurable": {"thread_id": thread_id}}
            response = agent.invoke(inputs, config=config)
            if isinstance(response, dict) and "messages" in response:
                print(f"Assistant: {response['messages'][-1].content}")
            else:
                print(f"Assistant: {response.content}")
        except Exception as e:
            print(e, file=sys.stderr)

import subprocess

def start_server(model_name, base_dir):
    print(f"🚀 Starting web server with model '{model_name}' and base directory '{base_dir}'...")
    subprocess.run(["python", "-m", "codepromptforge.assistant.web_assistant.app", "--model", model_name, "--base-dir", base_dir])

###############################
# Assistant Commands Registration
###############################
def register_commands(subparsers):
    # Register CLI assistant command
    parser_assistant = subparsers.add_parser("cli_assistant", help="Run the advanced assistant CLI")
    parser_assistant.add_argument("--model", required=True, help="Ollama model to use (e.g., llama3.3, qwen2.5:14b)")
    parser_assistant.add_argument("--base-dir", required=True, help="Base directory for assistant operations")
    parser_assistant.add_argument("--temperature", type=float, default=0.0, help="Temperature setting for the model")
    parser_assistant.add_argument("--num_ctx", type=int, default=80000, help="Context length for the model")
    parser_assistant.set_defaults(func=handle_assistant)

    # Register web assistant command
    parser_web = subparsers.add_parser("web_assistant", help="Start the advanced web assistant server")
    parser_web.add_argument("--model", required=True, help="Ollama model to use")
    parser_web.add_argument("--base-dir", required=True, help="Base directory for assistant operations")
    parser_web.set_defaults(func=handle_web)

def handle_assistant(args):
    start_assistant(args.model, args.base_dir, args.temperature, args.num_ctx)

def handle_web(args):
    start_server(args.model, args.base_dir)
### __init__.py ###
from .assistant_registry import AssistantRegistry
from . import react_assistant  # Ensure assistants are loaded

__all__ = ["AssistantRegistry"]
### assistant_registry.py ###
from typing import Dict, Callable

class AssistantRegistry:
    """
    A registry for managing and retrieving assistant implementations dynamically.
    Each assistant must be registered with a unique name and a function that 
    builds the assistant using an LLM model.
    """

    _registry: Dict[str, Callable] = {}

    @classmethod
    def register_assistant(cls, name: str, builder: Callable):
        """
        Register an assistant with a unique name.

        Args:
            name (str): Unique identifier for the assistant.
            builder (Callable): A function that takes an LLM instance and returns the assistant.

        Raises:
            ValueError: If an assistant with the same name is already registered.
        """
        if name in cls._registry:
            raise ValueError(f"Assistant '{name}' is already registered.")
        cls._registry[name] = builder

    @classmethod
    def get_assistant(cls, name: str, llm, base_dir='..'):
        """
        Retrieve and build an assistant by name.

        Args:
            name (str): The name of the registered assistant.
            llm: The LLM model instance to be used by the assistant.

        Returns:
            The built assistant instance.

        Raises:
            KeyError: If the requested assistant is not found.
        """
        if name not in cls._registry:
            raise KeyError(f"Assistant '{name}' is not registered.")
        return cls._registry[name](llm, base_dir)

    @classmethod
    def list_assistants(cls):
        """
        List all registered assistants.

        Returns:
            List of registered assistant names.
        """
        return list(cls._registry.keys())
### react_assistant.py ###

from ...core.main import CodePromptForge
from ...core.prompt import react_template
from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver

from .assistant_registry import AssistantRegistry

# Define the assistant's prompt
prompt = react_template + "You are forbidden to call tools beyond the list provided."
memory = MemorySaver()


# Define the assistant builder function
def build_react_assistant(llm, base_dir):
    # Define the tools
    forge = CodePromptForge(base_dir=base_dir)
    tools = forge.get_tools()
    return create_react_agent(llm, tools=tools, prompt=prompt, checkpointer=memory)

# Register the assistant
AssistantRegistry.register_assistant("react_assistant", build_react_assistant)
### __init__.py ###

### app.py ###
from flask import Flask, render_template, request, jsonify, session
from codepromptforge.assistant import AssistantRegistry
from langchain_ollama import ChatOllama
import ollama
import re
import argparse
import uuid
import os

APP_DIR = os.path.dirname(os.path.abspath(__file__)) 
TEMPLATES_PATH = os.path.join(APP_DIR, "templates")
STATIC_PATH = os.path.join(APP_DIR, "static")

print("🔥 Debug Info 🔥")
print(f"📂 Current Working Directory: {os.getcwd()}")
print(f"📁 Expected Templates Path: {TEMPLATES_PATH}")
print(f"📄 index.html Exists: {os.path.exists(os.path.join(TEMPLATES_PATH, 'index.html'))}")

# Initialize Flask with explicit template directory
app = Flask(__name__, template_folder=TEMPLATES_PATH, static_folder=STATIC_PATH)
app.secret_key = "supersecretkey"  # Required for session tracking

def get_available_models():
    """Returns a list of available models in Ollama."""
    try:
        return [m["name"] for m in ollama.list()["models"]]
    except Exception:
        return []

def format_response(response):
    """Formats assistant response to preserve code formatting."""
    response = re.sub(r"```python\n(.*?)\n```", r'<pre><code class="language-python">\1</code></pre>', response, flags=re.DOTALL)
    response = re.sub(r"```markdown\n(.*?)\n```", r'<pre><code class="language-markdown">\1</code></pre>', response, flags=re.DOTALL)
    return response.replace("\n", "<br>")

# Parse CLI arguments
parser = argparse.ArgumentParser(description="Start web assistant")
parser.add_argument("--model", required=True, help="Ollama model name")
parser.add_argument("--base-dir", required=True, help="Base directory for file operations")
args = parser.parse_args()

# Convert base_dir to an absolute path
BASE_DIR = os.path.abspath(args.base_dir)  # ✅ Ensure correct path

# Change working directory to base_dir
os.chdir(BASE_DIR)  # ✅ Ensure app has access to base_dir files

print(f"🔹 Server running with base directory: {BASE_DIR}")

# Initialize LLM
llm = ChatOllama(model=args.model)

# Retrieve assistant with `base_dir`
assistant_name = "react_assistant"
agent = AssistantRegistry.get_assistant(assistant_name, llm, BASE_DIR)  # ✅ Pass absolute base_dir

@app.route("/")
def index():
    """Render the chat UI."""
    if "thread_id" not in session:
        session["thread_id"] = str(uuid.uuid4())  # ✅ Generate unique thread_id

    return render_template(
        "index.html",
        models=get_available_models(),
        selected_model=args.model,
        base_dir=BASE_DIR,  # ✅ Pass absolute base_dir
        thread_id=session["thread_id"]
    )

@app.route("/chat", methods=["POST"])
def chat():
    """Handle user input with thread_id for session tracking."""
    user_input = request.json.get("message")
    if not user_input:
        return jsonify({"error": "Empty input!"}), 400

    thread_id = session.get("thread_id", str(uuid.uuid4()))  # ✅ Ensure thread_id persists

    inputs = {"messages": [("user", user_input)]}
    config = {"configurable": {"thread_id": thread_id}}  # ✅ Include memory tracking

    response = agent.invoke(inputs, config=config)

    assistant_response = response["messages"][-1].content if "messages" in response else response.content
    return jsonify({"message": format_response(assistant_response)})

if __name__ == "__main__":
    app.run(debug=True, port=5000)
### __init__.py ###
# codepromptforge/__init__.py
"""
codepromptforge package initialization module.

This package provides functionality to combine code files into a single prompt,
making it easy to use with large language models (LLMs) for tasks such as
bug fixing, code improvements, and modifications.
"""
### cli.py ###
import argparse
import json
import sys
from .main import CodePromptForge

##############################
# Core Commands Registration #
##############################
def register_core_commands(subparsers):
    # tree command
    parser_tree = subparsers.add_parser("tree", help="Display the directory tree")
    parser_tree.add_argument("--folder", required=True, help="Folder path")
    parser_tree.add_argument("--base-dir", required=True, help="Base directory")
    parser_tree.set_defaults(func=handle_tree)

    # file command
    parser_file = subparsers.add_parser("file", help="Display the content of a file")
    parser_file.add_argument("--file", required=True, help="File path")
    parser_file.add_argument("--base-dir", required=True, help="Base directory")
    parser_file.set_defaults(func=handle_file)

    # files command
    parser_files = subparsers.add_parser("files", help="List files in a folder")
    parser_files.add_argument("--folder", required=True, help="Folder path")
    parser_files.add_argument("--base-dir", required=True, help="Base directory")
    parser_files.set_defaults(func=handle_files)

    # files_recursive command
    parser_files_recursive = subparsers.add_parser("files_recursive", help="Recursively list files")
    parser_files_recursive.add_argument("--folder", required=True, help="Folder path")
    parser_files_recursive.add_argument("--base-dir", required=True, help="Base directory")
    parser_files_recursive.set_defaults(func=handle_files_recursive)

    # write command
    parser_write = subparsers.add_parser("write", help="Write content to a file")
    parser_write.add_argument("--file", required=True, help="File path")
    parser_write.add_argument("--content", required=True, help="Content to write")
    parser_write.add_argument("--base-dir", required=True, help="Base directory")
    parser_write.set_defaults(func=handle_write)

    # combine command
    parser_combine = subparsers.add_parser("combine", help="Combine files into an output file")
    parser_combine.add_argument("--extensions", nargs="+", required=True, help="List of file extensions")
    parser_combine.add_argument("--output-file", required=True, help="Output file for the combination")
    parser_combine.add_argument("--base-dir", required=True, help="Base directory")
    parser_combine.add_argument("--force", action="store_true", help="Force overwrite existing output file")
    parser_combine.add_argument("--exclude", nargs="*", default=[], help="Files to exclude from concatenation")
    parser_combine.set_defaults(func=handle_combine)

    # clean_result command
    parser_clean = subparsers.add_parser("clean_result", help="Clean the .result folder")
    parser_clean.add_argument("--exclude-clean", nargs="+", required=True, help="Files to remove from .result folder")
    parser_clean.add_argument("--base-dir", required=True, help="Base directory")
    parser_clean.set_defaults(func=handle_clean_result)

###########################
# Core Commands Handlers  #
###########################
def handle_tree(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        tree = forge.get_directory_tree(args.folder)
        print("\n".join(tree))
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_file(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        content = forge.get_file_content(args.file)
        print(content)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_files(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        files = forge.get_files_in_folder(args.folder)
        print(json.dumps(files, indent=2))
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_files_recursive(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        files = forge.get_files_recursively(args.folder)
        print(json.dumps(files, indent=2))
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_write(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        result = forge.write_file(args.file, args.content)
        print(result)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_combine(args):
    forge = CodePromptForge(
        base_dir=args.base_dir,
        output_file=args.output_file,
        force=args.force,
        excluded=args.exclude
    )
    try:
        forge.forge_prompt(args.extensions)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

def handle_clean_result(args):
    forge = CodePromptForge(base_dir=args.base_dir)
    try:
        forge.clean_result_folder(args.exclude_clean)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

#######################
# Main CLI Entry Point#
#######################
def main():
    parser = argparse.ArgumentParser(description="Code management CLI for CodePromptForge.")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # Register core commands
    register_core_commands(subparsers)

    # Optionally register assistant commands if the assistant module is installed.
    try:
        from ..assistant import cli as assistant_cli
        assistant_cli.register_commands(subparsers)
    except ImportError:
        # Assistant module is not installed; ignore extra commands.
        pass

    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
    else:
        print("No valid command selected.", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
### main.py ###
import os
from pathlib import Path
from typing import List, Dict, Optional, Type
from pydantic import BaseModel, Field
from langchain_core.tools import BaseTool
import pathspec  # ✅ Added for .gitignore handling
from langchain_community.tools import DuckDuckGoSearchRun, DuckDuckGoSearchResults
class InvalidBaseDirectoryError(Exception):
    pass

class NoFilesFoundError(Exception):
    pass

class OutputFileAlreadyExistsError(Exception):
    pass

class CodePromptForge:
    def __init__(
        self,
        base_dir: str = ".",
        output_file: str = None,
        dry_run: bool = False,
        force: bool = False,
        include_tree: bool = False,
        excluded: Optional[List[str]] = None
    ):
        self.base_dir = Path(base_dir).resolve()
        if not self.base_dir.exists() or not self.base_dir.is_dir():
            raise InvalidBaseDirectoryError(f"Base directory '{self.base_dir}' does not exist or is not a directory.")

        self.output_file = Path(output_file) if output_file else None
        self.dry_run = dry_run
        self.force = force
        self.include_tree = include_tree
        self.result_dir = self.base_dir / ".result"
        self.result_dir.mkdir(parents=True, exist_ok=True)

        # Load .gitignore patterns
        self.gitignore_spec = self._load_gitignore()

        # Convert excluded files into a set for quick lookup
        self.excluded = set(excluded or [])

    def _load_gitignore(self) -> Optional[pathspec.PathSpec]:
        """Loads `.gitignore` and compiles it into a pathspec matcher."""
        gitignore_path = self.base_dir / ".gitignore"
        if not gitignore_path.exists():
            return None  # No .gitignore found

        with gitignore_path.open("r", encoding="utf-8") as f:
            gitignore_patterns = f.readlines()

        return pathspec.PathSpec.from_lines("gitwildmatch", gitignore_patterns)

    def _is_ignored(self, file_path: Path) -> bool:
        """Checks if a file is ignored by .gitignore, explicitly excluded, or in `.git`."""
        relative_path = str(file_path.relative_to(self.base_dir))
        return (
            (self.gitignore_spec and self.gitignore_spec.match_file(relative_path))  # ✅ Checks against .gitignore
            or (relative_path in self.excluded)  # ✅ Explicit exclusions
            or (".git/" in relative_path or relative_path.startswith(".git"))  # ✅ Always ignore `.git`
        )

    def get_directory_tree(self, folder_path: str) -> List[str]:
        """Returns a list of all files in the specified folder, excluding ignored ones."""
        target_path = self.base_dir / folder_path
        if not target_path.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_path}")

        return [
            str(file.relative_to(self.base_dir))
            for file in target_path.rglob("*")
            if file.is_file() and not self._is_ignored(file)
        ]

    def get_file_content(self, file_path: str) -> str:
        target_file = self.base_dir / file_path
        if not target_file.is_file() or self._is_ignored(target_file):
            raise FileNotFoundError(f"File not found or ignored: {target_file}")
        return target_file.read_text(encoding="utf-8")

    def get_files_in_folder(self, folder_path: str) -> Dict[str, str]:
        target_folder = self.base_dir / folder_path
        if not target_folder.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_folder}")

        return {
            file.name: file.read_text(encoding="utf-8")
            for file in target_folder.iterdir()
            if file.is_file() and not self._is_ignored(file)
        }

    def get_files_recursively(self, folder_path: str) -> Dict[str, str]:
        target_folder = self.base_dir / folder_path
        if not target_folder.is_dir():
            raise InvalidBaseDirectoryError(f"Invalid directory: {target_folder}")

        return {
            str(file.relative_to(self.base_dir)): file.read_text(encoding="utf-8")
            for file in target_folder.rglob("*")
            if file.is_file() and not self._is_ignored(file)
        }

    def write_file(self, file_path: str, content: str) -> str:
        """Writes a file inside .result folder and ensures it exists."""
        self.result_dir.mkdir(parents=True, exist_ok=True)
        result_file = self.result_dir / file_path
        result_file.write_text(content, encoding="utf-8")
        return f"File written successfully: {result_file}"

    def find_files(self, extensions: List[str]) -> List[Path]:
        matched_files = [
            file_path
            for ext in extensions
            for file_path in self.base_dir.rglob(f"*.{ext}")
            if not self._is_ignored(file_path)
        ]
        if not matched_files:
            raise NoFilesFoundError(f"No files found for extensions {extensions} in '{self.base_dir}'.")
        return sorted(set(matched_files))

    def _validate_output_file(self) -> None:
        """Ensures output file does not already exist unless force=True."""
        if self.output_file and self.output_file.exists() and not self.force:
            raise OutputFileAlreadyExistsError(
                f"Output file '{self.output_file}' already exists. Use --force to overwrite."
            )

    def forge_prompt(self, extensions: List[str]) -> None:
        self._validate_output_file()
        files = self.find_files(extensions)
        if self.dry_run:
            print("\n".join(str(f) for f in files))
            return
        if not files:
            print("No files found for combination.")
            return
        self.output_file.parent.mkdir(parents=True, exist_ok=True)
        with self.output_file.open('w', encoding='utf-8') as outfile:
            if self.include_tree:
                outfile.write("Directory Tree:\n")
                outfile.write("\n".join(self.get_directory_tree(".")) + "\n")
            for file in files:
                outfile.write(f"### {file.name} ###\n")
                outfile.write(file.read_text(encoding="utf-8"))
                outfile.write("\n")

    def run(self, extensions: List[str]) -> None:
        self.forge_prompt(extensions)

    def clean_result_folder(self, excluded_files: List[str]) -> None:
        self.result_dir.mkdir(parents=True, exist_ok=True)
        deleted_files = []
        for file_name in excluded_files:
            file_path = self.result_dir / file_name
            if file_path.exists() and file_path.is_file():
                file_path.unlink()
                deleted_files.append(file_name)
        print(f"Cleaned .result folder. Removed files: {deleted_files}")

    def get_tools(self) -> List[BaseTool]:
        """Returns LangChain-compatible tools with access to CodePromptForge methods."""

        class GetDirectoryTreeInput(BaseModel):
            folder_path: str = Field(..., description="The directory path to generate a tree from.")

        class GetFileContentInput(BaseModel):
            file_path: str = Field(..., description="Path of the file to read.")

        class WriteFileInput(BaseModel):
            file_path: str = Field(..., description="Path to save the file.")
            content: str = Field(..., description="Content to be written in the file.")

        class CleanResultFolderInput(BaseModel):
            excluded_files: List[str] = Field(..., description="List of filenames to remove inside .result folder.")

        class GetFilesInFolderInput(BaseModel):
            folder_path: str = Field(..., description="Path of the folder to list files from.")

        class GetFilesRecursivelyInput(BaseModel):
            folder_path: str = Field(..., description="Path of the folder to recursively list files.")

        class FindFilesInput(BaseModel):
            extensions: List[str] = Field(..., description="List of file extensions to search for.")

        class ForgePromptInput(BaseModel):
            extensions: List[str] = Field(..., description="List of file extensions to include in the prompt.")

        forge = self

        class GetDirectoryTreeTool(BaseTool):
            name: str = "get_directory_tree"
            description: str = "Returns a list of all files in the specified folder, with paths relative to the base directory."
            args_schema: Type[BaseModel] = GetDirectoryTreeInput

            def _run(self, folder_path: str) -> List[str]:
                return forge.get_directory_tree(folder_path)

        class GetFileContentTool(BaseTool):
            name: str = "get_file_content"
            description: str = "Retrieves the content of a specified file."
            args_schema: Type[BaseModel] = GetFileContentInput

            def _run(self, file_path: str) -> str:
                return forge.get_file_content(file_path)

        class GetFilesInFolderTool(BaseTool):
            name: str = "get_files_in_folder"
            description: str = "Lists all files in the specified folder."
            args_schema: Type[BaseModel] = GetFilesInFolderInput

            def _run(self, folder_path: str) -> Dict[str, str]:
                return forge.get_files_in_folder(folder_path)

        class GetFilesRecursivelyTool(BaseTool):
            name: str = "get_files_recursively"
            description: str = "Lists all files in a folder and its subfolders."
            args_schema: Type[BaseModel] = GetFilesRecursivelyInput

            def _run(self, folder_path: str) -> Dict[str, str]:
                return forge.get_files_recursively(folder_path)

        class FindFilesTool(BaseTool):
            name: str = "find_files"
            description: str = "Finds files with the specified extensions in the base directory."
            args_schema: Type[BaseModel] = FindFilesInput

            def _run(self, extensions: List[str]) -> List[str]:
                return [str(file) for file in forge.find_files(extensions)]

        class WriteFileTool(BaseTool):
            name: str = "write_file"
            description: str = "Writes content to a file inside the .result folder."
            args_schema: Type[BaseModel] = WriteFileInput

            def _run(self, file_path: str, content: str) -> str:
                return forge.write_file(file_path, content)

        class CleanResultFolderTool(BaseTool):
            name: str = "clean_result_folder"
            description: str = "Deletes specific files inside the .result folder."
            args_schema: Type[BaseModel] = CleanResultFolderInput

            def _run(self, excluded_files: List[str]) -> None:
                return forge.clean_result_folder(excluded_files)

        class ForgePromptTool(BaseTool):
            name: str = "forge_prompt"
            description: str = "Combines and processes code files into a single prompt."
            args_schema: Type[BaseModel] = ForgePromptInput

            def _run(self, extensions: List[str]) -> None:
                return forge.forge_prompt(extensions)

        class RunTool(BaseTool):
            name: str = "run"
            description: str = "Runs the forge process on the specified file extensions."
            args_schema: Type[BaseModel] = ForgePromptInput

            def _run(self, extensions: List[str]) -> None:
                return forge.run(extensions)

        return [
            GetDirectoryTreeTool(),
            GetFileContentTool(),
            GetFilesInFolderTool(),
            GetFilesRecursivelyTool(),
            FindFilesTool(),
            WriteFileTool(),
            CleanResultFolderTool(),
            ForgePromptTool(),
            RunTool(),
            DuckDuckGoSearchRun(), 
            DuckDuckGoSearchResults(backend="news")
        ]
### prompt.py ###
react_template = """
You are an AI code reviewer and generator, responsible for analyzing and improving software projects. Your goal is to assist in reviewing, modifying, and generating high-quality code while leveraging the available tools.

You may also be requested to generate prompts with enougth context to fix or write a new feature.

Be friendly and chat with the user about any topic. You may search the web, using duckduckgo, to gather additional context to answer questions or to interact.
Don`t call other tools unless you engage in a code review process.

When asked to work on a codebase here are your Guidelines

	1.	Understand the Context
	•	Start by retrieving the directory tree using get_directory_tree to get an overview of the project.
	•	Identify relevant files for analysis using find_files (e.g., Python, JavaScript, or other specified extensions).
	2.	Analyze the Codebase
	•	Read individual files with get_file_content to understand their structure and functionality.
	•	If a specific folder needs inspection, use get_files_in_folder or get_files_recursively.
	3.	Apply Code Review Principles
	•	Look for bugs, security risks, and inefficiencies in the code.
	•	Identify inconsistent styles, redundant code, or performance issues.
	•	Ensure compliance with best practices and design patterns.
	4.	Enhance and Optimize Code
	•	If issues are found, suggest improvements, refactors, or optimizations.
	•	If a function, class, or module is missing, generate the necessary code.
	•	Ensure that any new code aligns with existing conventions and patterns.
	5.	Write and Save Modifications
	•	If a change is required, write modified code to a file using write_file.
	•	If multiple changes are needed, manage them efficiently without overwriting critical files.
	6.	Ensure Clean Project State
	•	Before finalizing, check the .result folder for unnecessary files and remove them using clean_result_folder.
	•	Ensure that ignored files (from .gitignore) are not included in the process.

Tools Available

You have access to the following tools:
	•	get_directory_tree(folder_path): Retrieve a list of all files in a given folder.
	•	get_file_content(file_path): Read the contents of a specific file.
	•	get_files_in_folder(folder_path): List all files in a folder.
	•	get_files_recursively(folder_path): Retrieve files from a folder and its subdirectories.
	•	find_files(extensions): Find all files matching a given set of extensions.
	•	write_file(file_path, content): Write or overwrite a file.
	•	clean_result_folder(excluded_files): Remove unnecessary files from the .result folder.
	•	forge_prompt(extensions): Generate a combined prompt from selected files.
	•	duckduckgo_search(query: str): Searchs the web
    •	duckduckgo_results_json(query: str): Searchs the web, and returns news and more detailed info


Expected Workflow for codereview
	1.	Retrieve the project structure using get_directory_tree.
	2.	Identify key files using find_files(["py"]) (or other specified extensions).
	3.	Analyze relevant files using get_file_content.
	4.	Identify areas for improvement (bugs, optimizations, security).
	5.	Suggest and generate improved code where necessary.
	6.	Write updated files using write_file without overriding critical files.
	7.	Ensure clean project state using clean_result_folder where appropriate.

Your task is to review, analyze, and generate code while following best practices. If modifications are needed, ensure they are well-structured and aligned with the existing codebase.
or, just assist the user with his/her needs. Use unicode emoji`s to make the conversation more interesting and engaging
"""

